#!/usr/bin/env python3\n\"\"\"\nPerformance monitoring script for Parts Interchange Database\nHelps identify slow queries and bottlenecks in the admin interface\n\"\"\"\n\nimport os\nimport sys\nimport time\nfrom pathlib import Path\n\n# Add the parts_interchange directory to Python path\nproject_root = Path(__file__).resolve().parent\nparts_interchange_dir = project_root / 'parts_interchange'\nsys.path.insert(0, str(parts_interchange_dir))\n\n# Set up Django\nos.environ.setdefault('DJANGO_SETTINGS_MODULE', 'parts_interchange.settings')\n\nimport django\ndjango.setup()\n\nfrom django.db import connection\nfrom django.core.management import execute_from_command_line\nfrom django.test.utils import override_settings\n\ndef test_database_connection():\n    \"\"\"Test basic database connectivity and response time\"\"\"\n    print(\"=== Database Connection Test ===\")\n    \n    start_time = time.time()\n    try:\n        with connection.cursor() as cursor:\n            cursor.execute(\"SELECT 1\")\n            result = cursor.fetchone()\n        \n        connection_time = (time.time() - start_time) * 1000\n        print(f\"âœ… Database connection: {connection_time:.1f}ms\")\n        \n        if connection_time > 100:\n            print(\"âš ï¸  WARNING: Database connection is slow (>100ms)\")\n            print(\"   This suggests network latency to Render database\")\n        \n        return connection_time\n    except Exception as e:\n        print(f\"âŒ Database connection failed: {e}\")\n        return None\n\ndef test_admin_queries():\n    \"\"\"Test common admin interface queries\"\"\"\n    print(\"\\n=== Admin Interface Query Performance ===\")\n    \n    from apps.parts.models import Part, Manufacturer\n    from apps.vehicles.models import Vehicle\n    from apps.fitments.models import Fitment\n    \n    tests = [\n        (\"Parts list (admin)\", lambda: list(Part.objects.select_related('manufacturer', 'category')[:10])),\n        (\"Vehicles list (admin)\", lambda: list(Vehicle.objects.select_related('make', 'model', 'trim', 'engine')[:10])),\n        (\"Manufacturers list\", lambda: list(Manufacturer.objects.all()[:10])),\n        (\"Part with fitments\", lambda: Part.objects.prefetch_related('fitments__vehicle').first()),\n        (\"Vehicle with fitments\", lambda: Vehicle.objects.prefetch_related('fitments__part').first()),\n    ]\n    \n    for test_name, query_func in tests:\n        start_time = time.time()\n        try:\n            result = query_func()\n            query_time = (time.time() - start_time) * 1000\n            \n            if query_time > 200:\n                status = \"ðŸ”´ SLOW\"\n            elif query_time > 100:\n                status = \"ðŸŸ¡ MEDIUM\"\n            else:\n                status = \"ðŸŸ¢ FAST\"\n            \n            print(f\"{status} {test_name}: {query_time:.1f}ms\")\n            \n        except Exception as e:\n            print(f\"âŒ {test_name}: ERROR - {e}\")\n\ndef show_query_analysis():\n    \"\"\"Show SQL query analysis\"\"\"\n    print(\"\\n=== Query Analysis ===\")\n    \n    # Reset query log\n    connection.queries_log.clear()\n    \n    # Run a typical admin query\n    from apps.parts.models import Part\n    parts = list(Part.objects.select_related('manufacturer', 'category')[:5])\n    \n    print(f\"Queries executed: {len(connection.queries)}\")\n    \n    for i, query in enumerate(connection.queries, 1):\n        time_ms = float(query['time']) * 1000\n        if time_ms > 50:\n            status = \"ðŸ”´ SLOW\"\n        elif time_ms > 20:\n            status = \"ðŸŸ¡ MEDIUM\"\n        else:\n            status = \"ðŸŸ¢ FAST\"\n        \n        print(f\"{status} Query {i}: {time_ms:.1f}ms\")\n        if time_ms > 50:\n            # Show slow queries\n            sql = query['sql'][:100] + \"...\" if len(query['sql']) > 100 else query['sql']\n            print(f\"     SQL: {sql}\")\n\ndef get_database_stats():\n    \"\"\"Get database statistics\"\"\"\n    print(\"\\n=== Database Statistics ===\")\n    \n    with connection.cursor() as cursor:\n        # Get table sizes (PostgreSQL specific)\n        try:\n            cursor.execute(\"\"\"\n                SELECT \n                    schemaname,\n                    tablename,\n                    attname,\n                    n_distinct,\n                    correlation\n                FROM pg_stats \n                WHERE schemaname = 'public' \n                AND tablename IN ('parts_part', 'vehicles_vehicle', 'fitments_fitment')\n                ORDER BY tablename, attname\n                LIMIT 10\n            \"\"\")\n            \n            stats = cursor.fetchall()\n            if stats:\n                print(\"Table statistics:\")\n                for schema, table, column, distinct, correlation in stats:\n                    print(f\"  {table}.{column}: {distinct} distinct values\")\n            \n        except Exception as e:\n            print(f\"Could not get table stats: {e}\")\n        \n        # Get record counts\n        tables = [\n            ('parts_part', 'Parts'),\n            ('vehicles_vehicle', 'Vehicles'),\n            ('fitments_fitment', 'Fitments'),\n            ('parts_manufacturer', 'Manufacturers')\n        ]\n        \n        print(\"\\nRecord counts:\")\n        for table, name in tables:\n            try:\n                cursor.execute(f\"SELECT COUNT(*) FROM {table}\")\n                count = cursor.fetchone()[0]\n                print(f\"  {name}: {count:,} records\")\n            except Exception as e:\n                print(f\"  {name}: Error getting count\")\n\ndef show_recommendations():\n    \"\"\"Show performance recommendations\"\"\"\n    print(\"\\n=== Performance Recommendations ===\")\n    \n    print(\"For 50-200ms response times on live data entry:\")\n    print(\"\\nðŸŽ¯ IMMEDIATE ACTIONS:\")\n    print(\"1. Reduce admin page sizes to 5-10 items per page\")\n    print(\"2. Use autocomplete widgets for foreign keys\")\n    print(\"3. Enable database connection pooling\")\n    print(\"4. Consider upgrading Render database plan\")\n    \n    print(\"\\nðŸ”§ DATABASE OPTIMIZATIONS:\")\n    print(\"1. Ensure all performance indexes are created\")\n    print(\"2. Run VACUUM ANALYZE on PostgreSQL\")\n    print(\"3. Monitor connection pool usage\")\n    \n    print(\"\\nðŸš€ ARCHITECTURAL IMPROVEMENTS:\")\n    print(\"1. Implement Redis caching for frequent lookups\")\n    print(\"2. Use database connection pooling (PgBouncer)\")\n    print(\"3. Consider read replicas for heavy queries\")\n    print(\"4. Move to a geographically closer database region\")\n    \n    print(\"\\nâš¡ FRONTEND OPTIMIZATIONS:\")\n    print(\"1. Use AJAX for form submissions\")\n    print(\"2. Implement client-side caching\")\n    print(\"3. Add loading indicators for user feedback\")\n    print(\"4. Use autocomplete for part/vehicle selection\")\n\ndef main():\n    print(\"Parts Interchange Database - Performance Analysis\")\n    print(\"=\" * 50)\n    \n    # Test database connection\n    conn_time = test_database_connection()\n    \n    if conn_time is None:\n        print(\"âŒ Cannot proceed - database connection failed\")\n        return\n    \n    # Test admin queries\n    test_admin_queries()\n    \n    # Show query analysis\n    with override_settings(DEBUG=True):  # Enable query logging\n        show_query_analysis()\n    \n    # Get database stats\n    get_database_stats()\n    \n    # Show recommendations\n    show_recommendations()\n    \n    print(\"\\n=== SUMMARY ===\")\n    if conn_time > 100:\n        print(\"ðŸ”´ PRIMARY ISSUE: Database connection latency\")\n        print(\"   - Consider upgrading Render database plan\")\n        print(\"   - Implement connection pooling\")\n        print(\"   - Reduce query complexity\")\n    else:\n        print(\"ðŸŸ¢ Database connection is acceptable\")\n        print(\"   - Focus on query optimization\")\n        print(\"   - Implement caching for frequent operations\")\n\nif __name__ == '__main__':\n    main()\n